# С клавиатуры вводится последовательность неотрицательных чисел. Сначала
# указывается количество элементов последовательности, а затем идут
# сами элементы; каждый элемент указывается в отдельной строке. Некоторые
# элементы в последовательности могут повторяться. Найти два элемента
# последовательности (необязательно различные), которые отстоят друг от
# друга не менее чем на 4 позиции и при этом дают максимальную сумму,
# НЕ делящуюся на 12. Если такую сумму получить не удастся,
# напишите в ответе число -1.

n = int(input()) # количество элементов последовательности

# Небольшой список (массив), в котором мы будем хранить промежуточные
# элементы, находящиеся между "левой областью" и "правым элементом"
buf = 4 * [0]

# Список из 12 ячеек, в который мы запишем наибольшие элементы
# левой области, дающие при делении на 12 нужный остаток.
# Так, в ячейке max_left[r] будет храниться наибольший элемент, у которого
# остаток при делении на 12 равен `r`.
max_left = 12 * [-1]

# Читаем первые 4 элемента и записываем их в ячейки буфера
for i in range(4):
    buf[i] = int(input())

max_sum = -1  # наибольшая сумма двух элементов, отстоящих на 4 и более позиции, которая не делится на 12, - ответ на вопрос задачи
a, b = -1, -1

# Запускаем основной цикл
for i in range(4, n):
    right_element = int(input()) # "правый элемент"

    # В левую область добавляется новый элемент: это buf[0].
    # Обновим нужный максимум в левой области с учётом такого "пополнения".
    r = buf[0] % 12
    if buf[0] > max_left[r]: max_left[r] = buf[0]

    # Посмотрим, какой остаток при делении на 12 даёт правый элемент,
    # и в зависимости от этого сложим его с нужным максимумами левой области.

    s = right_element % 12

    for r in range(12):
        if (s + r) % 12 != 0:
            if max_left[r] != -1:
                summa = max_left[r] + right_element
                if summa > max_sum:
                    max_sum = summa
                    a, b = max_left[r] + right_element

    # Сдвинем все элементы в буфере на одну позицию влево, чтобы
    # освободить место для нового правого элемента, который мы прочитаем
    # на следующей итерации цикла. После этого в крайнюю правую ячейку
    # буфера запишем нынешний правый элемент, поставив его на конвейер.
    for j in range(1, 4):
        buf[j - 1] = buf[j]
    buf[3] = right_element

print(max_pro)
print(a, b)
